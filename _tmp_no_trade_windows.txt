from __future__ import annotations

from typing import Tuple, List, Optional

from .config import RunConfig
from .mt5_utils import pip_size_from_info


def check_spread(mt5_ctx: dict, cfg: RunConfig) -> Optional[str]:
    """Return reason string if current spread is too high, else None.

    Mirrors existing logic: prefer 5m p90, fallback to median, scaled by
    nt_spread_factor (min 1.0).
    """
    info = (mt5_ctx.get("info") or {})
    
    spread_cur = info.get("spread_current")
    p90_sp = tick_stats.get("p90_spread")
    median_sp = tick_stats.get("median_spread")
    if spread_cur is None:
        return None
    try:
        fac = max(1.0, float(cfg.nt_spread_factor))
    except Exception:
        fac = 1.0
    if p90_sp:
        if spread_cur > p90_sp * fac:
            return f"Spread cao (cur={spread_cur}, p90={p90_sp}, factor={fac})"
    elif median_sp:
        if spread_cur > median_sp * (fac + 0.1):
            return f"Spread cao (cur={spread_cur}, median~{median_sp})"
    return None


def check_atr_m5(mt5_ctx: dict, cfg: RunConfig) -> Optional[str]:
    """Return reason string if ATR M5 (in pips) is too low, else None."""
    info = (mt5_ctx.get("info") or {})
    
    
    
    if not atr_m5 or not pip_size or pip_size <= 0:
        return None
    try:
        
        if atr_m5_pips < float(cfg.nt_min_atr_m5_pips):
            return f"ATR M5 th?p ({atr_m5_pips:.1f} pips)"
    except Exception:
        pass
    return None


def check_liquidity(mt5_ctx: dict, cfg: RunConfig) -> Optional[str]:
    """Return reason string if ticks-per-minute is below threshold, else None."""
    tick_stats = (mt5_ctx.get("tick_stats_5m") or {})
    tpm = tick_stats.get("ticks_per_min")
    if tpm is None:
        return None
    try:
        if tpm < int(cfg.nt_min_ticks_per_min):
            return f"Thanh kho?n th?p (ticks/min={tpm})"
    except Exception:
        pass
    return None


def pretrade_hard_filters(mt5_ctx: dict, cfg: RunConfig) -> Tuple[bool, List[str]]:
    """Evaluate NO-TRADE hard filters using MT5 context and run config.

    Returns a tuple (ok, reasons). If ok is False, reasons contains human
    readable explanations for why trading should be skipped.
    """
    if not getattr(cfg, "nt_enabled", False):
        return True, []

    reasons: List[str] = []
    # Split checks (spread/ATR/liquidity); behavior preserved
    for fn in (check_spread, check_atr_m5, check_liquidity):
        try:
            why = fn(mt5_ctx, cfg)
            if why:
                reasons.append(why)
        except Exception:
            pass
    return (len(reasons) == 0), reasons
    tick_stats = (mt5_ctx.get("tick_stats_5m") or {})
    vol = (mt5_ctx.get("volatility") or {}).get("ATR") or {}

    

    

    atr_m5 = vol.get("M5")
    pip_size = pip_size_from_info(info)
    
        
        if atr_m5_pips < float(cfg.nt_min_atr_m5_pips):
            reasons.append(f"ATR M5 thấp ({atr_m5_pips:.1f} pips)")

    if tpm is not None and tpm < int(cfg.nt_min_ticks_per_min):
        reasons.append(f"Thanh khoản thấp (ticks/min={tpm})")

    return (len(reasons) == 0), reasons
