class ChartTabTV:
    """
    Lớp "ChartTabTV" đại diện cho một thành phần chính của ứng dụng.
    Trách nhiệm chính:
      - Khởi tạo UI (Notebook: Report/Prompt/Options, v.v.).
      - Đọc/ghi workspace, cache, prompt.
      - Quy trình phân tích 1 lần: nạp ảnh → (tối ưu/cache) upload → gọi Gemini → gom báo cáo.
      - (Tuỳ chọn) Lấy dữ liệu MT5, tạo JSON ngữ cảnh, lọc NO-TRADE, gửi Telegram.
      - Quản trị thread an toàn với Tkinter thông qua hàng đợi UI.
    """
    def __init__(self, app, notebook):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - app — (tự suy luận theo ngữ cảnh sử dụng).
          - notebook — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        self.app = app
        self.root = app.root

                             
        self.symbol_var = tk.StringVar(value="XAUUSD")                       
        self.tf_var = tk.StringVar(value="M1")
        self.n_candles_var = tk.IntVar(value=100)
        self.refresh_secs_var = tk.IntVar(value=1)

        self._after_job = None
        self._running = False

                           
        self.tab = ttk.Frame(notebook, padding=8)
        notebook.add(self.tab, text="Chart")

        self.tab.rowconfigure(1, weight=1)
        self.tab.columnconfigure(0, weight=2)
        self.tab.columnconfigure(1, weight=1)

                                      
        ctrl = ttk.Frame(self.tab)
        ctrl.grid(row=0, column=0, columnspan=2, sticky="ew", pady=(0, 6))
        for i in range(10):
            ctrl.columnconfigure(i, weight=0)
        ctrl.columnconfigure(9, weight=1)

        ttk.Label(ctrl, text="Symbol:").grid(row=0, column=0, sticky="w")

                                        
        self.cbo_symbol = ttk.Combobox(
            ctrl, width=16, textvariable=self.symbol_var, state="normal", values=[]
        )
        self.cbo_symbol.grid(row=0, column=1, sticky="w", padx=(4, 10))
        self.cbo_symbol.bind("<<ComboboxSelected>>", lambda e: self._redraw_safe())
        self._populate_symbol_list()                                        

        ttk.Label(ctrl, text="TF:").grid(row=0, column=2, sticky="w")
        self.cbo_tf = ttk.Combobox(
            ctrl, width=6, state="readonly",
            values=["M1", "M5", "M15", "H1", "H4", "D1"], textvariable=self.tf_var
        )
        self.cbo_tf.grid(row=0, column=3, sticky="w", padx=(4, 10))
        self.cbo_tf.bind("<<ComboboxSelected>>", lambda e: self._redraw_safe())

        ttk.Label(ctrl, text="Số nến:").grid(row=0, column=4, sticky="w")
        ttk.Spinbox(ctrl, from_=50, to=5000, textvariable=self.n_candles_var, width=8,
                    command=self._redraw_safe).grid(row=0, column=5, sticky="w", padx=(4, 10))

        ttk.Label(ctrl, text="Làm mới (s):").grid(row=0, column=6, sticky="w")
        ttk.Spinbox(ctrl, from_=1, to=3600, textvariable=self.refresh_secs_var, width=6)\
            .grid(row=0, column=7, sticky="w", padx=(4, 10))

                                                               
                                                                                 
        self.btn_start = ttk.Button(ctrl, text="► Start", command=self.start)
        self.btn_start.grid(row=0, column=8, sticky="w")
        self.btn_stop = ttk.Button(ctrl, text="□ Stop", command=self.stop, state="disabled")
        self.btn_stop.grid(row=0, column=9, sticky="w", padx=(6, 10))
        try:
            self.btn_start.grid_remove()
            self.btn_stop.grid_remove()
        except Exception:
            pass

                                                                  
                                                                         
        self.root.after(200, self.start)

                                                                 

                                                            
        chart_wrap = ttk.Frame(self.tab)
        chart_wrap.grid(row=1, column=0, sticky="nsew", padx=(0, 6))
        chart_wrap.rowconfigure(1, weight=1)
        chart_wrap.columnconfigure(0, weight=1)

                                                                                                               
        self.fig = Figure(figsize=(6, 4), dpi=100, constrained_layout=False)
        self.ax_price = self.fig.add_subplot(1, 1, 1)

        self.canvas = FigureCanvasTkAgg(self.fig, master=chart_wrap)
        self.canvas.get_tk_widget().grid(row=1, column=0, sticky="nsew")

                            
        try:
            from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
            tb_frame = ttk.Frame(chart_wrap)
            tb_frame.grid(row=0, column=0, sticky="ew", pady=(0, 4))
            self.toolbar = NavigationToolbar2Tk(self.canvas, tb_frame)
            self.toolbar.update()
        except Exception:
            self.toolbar = None

                       
        acc_box = ttk.LabelFrame(self.tab, text="Account info", padding=8)
        acc_box.grid(row=1, column=1, sticky="nsew")
        for i in range(2):
            acc_box.columnconfigure(i, weight=1)

        self.acc_balance = tk.StringVar(value="-")
        self.acc_equity = tk.StringVar(value="-")
        self.acc_margin = tk.StringVar(value="-")
        self.acc_leverage = tk.StringVar(value="-")
        self.acc_currency = tk.StringVar(value="-")
        self.acc_status = tk.StringVar(value="Chưa kết nối MT5")

        ttk.Label(acc_box, text="Balance:").grid(row=0, column=0, sticky="w")
        ttk.Label(acc_box, textvariable=self.acc_balance).grid(row=0, column=1, sticky="e")
        ttk.Label(acc_box, text="Equity:").grid(row=1, column=0, sticky="w")
        ttk.Label(acc_box, textvariable=self.acc_equity).grid(row=1, column=1, sticky="e")
        ttk.Label(acc_box, text="Free margin:").grid(row=2, column=0, sticky="w")
        ttk.Label(acc_box, textvariable=self.acc_margin).grid(row=2, column=1, sticky="e")
        ttk.Label(acc_box, text="Leverage:").grid(row=3, column=0, sticky="w")
        ttk.Label(acc_box, textvariable=self.acc_leverage).grid(row=3, column=1, sticky="e")
        ttk.Label(acc_box, text="Currency:").grid(row=4, column=0, sticky="w")
        ttk.Label(acc_box, textvariable=self.acc_currency).grid(row=4, column=1, sticky="e")
        ttk.Separator(acc_box, orient="horizontal").grid(row=5, column=0, columnspan=2, sticky="ew", pady=6)
        ttk.Label(acc_box, textvariable=self.acc_status, foreground="#666").grid(row=6, column=0, columnspan=2, sticky="w")

                                                  
        grids = ttk.Frame(self.tab)
        grids.grid(row=2, column=0, columnspan=2, sticky="nsew", pady=(6, 0))
        grids.columnconfigure(0, weight=1)
        grids.columnconfigure(1, weight=1)
        grids.rowconfigure(0, weight=1)

                                              
        pos_box = ttk.LabelFrame(grids, text="Open positions", padding=6)
        pos_box.grid(row=0, column=0, sticky="nsew", padx=(0, 4))
        pos_box.rowconfigure(0, weight=1)
        pos_box.columnconfigure(0, weight=1)

        self.pos_cols = ("ticket", "type", "lots", "price", "sl", "tp", "pnl")
        self.tree_pos = ttk.Treeview(pos_box, columns=self.pos_cols, show="headings", height=6)
        for c, w in zip(self.pos_cols, (90, 110, 70, 110, 110, 110, 100)):
            self.tree_pos.heading(c, text=c.upper())
            self.tree_pos.column(c, width=w, anchor="e" if c in ("lots", "price", "sl", "tp", "pnl") else "w")
        self.tree_pos.grid(row=0, column=0, sticky="nsew")
        scr1 = ttk.Scrollbar(pos_box, orient="vertical", command=self.tree_pos.yview)
        self.tree_pos.configure(yscrollcommand=scr1.set)
        scr1.grid(row=0, column=1, sticky="ns")

                 
        his_box = ttk.LabelFrame(grids, text="History (deals gần nhất)", padding=6)
        his_box.grid(row=0, column=1, sticky="nsew", padx=(4, 0))
        his_box.rowconfigure(0, weight=1)
        his_box.columnconfigure(0, weight=1)
        self.his_cols = ("time", "ticket", "type", "volume", "price", "profit")
        self.tree_his = ttk.Treeview(his_box, columns=self.his_cols, show="headings", height=6)
        for c, w in zip(self.his_cols, (140, 90, 70, 80, 110, 100)):
            self.tree_his.heading(c, text=c.upper())
            self.tree_his.column(c, width=w, anchor="e" if c in ("volume", "price", "profit") else "w")
        self.tree_his.grid(row=0, column=0, sticky="nsew")
        scr2 = ttk.Scrollbar(his_box, orient="vertical", command=self.tree_his.yview)
        self.tree_his.configure(yscrollcommand=scr2.set)
        scr2.grid(row=0, column=1, sticky="ns")

                    
        self._redraw_safe()

                                 
    def start(self):
        """
        Mục đích: Bắt đầu quy trình chính (khởi tạo trạng thái, đọc cấu hình, chạy tác vụ nền).
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        if self._running:
            return
        self._running = True
        self.btn_start.configure(state="disabled")
        self.btn_stop.configure(state="normal")
        self._tick()

    def stop(self):
        """
        Mục đích: Dừng quy trình đang chạy một cách an toàn (đặt cờ, giải phóng tài nguyên, cập nhật UI).
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        self._running = False
        if self._after_job:
            self.root.after_cancel(self._after_job)
            self._after_job = None
        self.btn_start.configure(state="normal")
        self.btn_stop.configure(state="disabled")

                         
    def _populate_symbol_list(self):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            if not self._ensure_mt5(want_account=False):
                return
            import MetaTrader5 as mt5
            syms = mt5.symbols_get()
            names = sorted([s.name for s in syms]) if syms else []
            if names:
                self.cbo_symbol["values"] = names
                                                                                 
                if "XAUUSD" in names:
                    self.symbol_var.set("XAUUSD")
        except Exception:
            pass


    def _mt5_tf(self, tf_str: str):
        """
        Mục đích: Tương tác với MetaTrader 5 (kết nối, lấy dữ liệu nến, tính toán chỉ số, snapshot...).
        Tham số:
          - tf_str: str — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            import MetaTrader5 as mt5
        except Exception:
            return None
        mapping = {
            "M1": mt5.TIMEFRAME_M1,
            "M5": mt5.TIMEFRAME_M5,
            "M15": mt5.TIMEFRAME_M15,
            "H1": mt5.TIMEFRAME_H1,
            "H4": mt5.TIMEFRAME_H4,
            "D1": mt5.TIMEFRAME_D1,
        }
        return mapping.get(tf_str.upper(), mt5.TIMEFRAME_M5)

    def _ensure_mt5(self, *, want_account: bool = True) -> bool:
        """
        Mục đích: Tương tác với MetaTrader 5 (kết nối, lấy dữ liệu nến, tính toán chỉ số, snapshot...).
        Tham số: (không)
        Trả về: bool
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            import MetaTrader5 as mt5
        except Exception:
            self.acc_status.set("Chưa cài MetaTrader5 (pip install MetaTrader5)")
            return False

                                                         
        if getattr(self.app, "mt5_initialized", False):
            if want_account and mt5.account_info() is None:
                self.acc_status.set("MT5: chưa đăng nhập (account_info=None)")
                return False
            return True

                                                             
        if getattr(self.app, "mt5_enabled_var", None) and self.app.mt5_enabled_var.get():
            try:
                self.app._mt5_connect()
            except Exception:
                pass
            if getattr(self.app, "mt5_initialized", False):
                if want_account and mt5.account_info() is None:
                    self.acc_status.set("MT5: chưa đăng nhập (account_info=None)")
                    return False
                return True

                                
        if not mt5.initialize():
            code, msg = mt5.last_error()
            self.acc_status.set(f"MT5 init fail: {code} {msg}")
            return False

        if want_account and mt5.account_info() is None:
            code, msg = mt5.last_error()
            self.acc_status.set(f"MT5: chưa đăng nhập (account_info=None). last_error={code} {msg}")
            return False

        return True


    def _rates_to_df(self, symbol, tf_code, count: int):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - symbol — (tự suy luận theo ngữ cảnh sử dụng).
          - tf_code — (tự suy luận theo ngữ cảnh sử dụng).
          - count: int — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        if not self._ensure_mt5():
            return pd.DataFrame()
        import MetaTrader5 as mt5
        try:
            if not symbol:
                self.acc_status.set("Symbol rỗng")
                return pd.DataFrame()

            info = mt5.symbol_info(symbol)
            if info is None:
                self.acc_status.set(f"Symbol không tồn tại trong MT5: {symbol}")
                return pd.DataFrame()
            if not info.visible:
                mt5.symbol_select(symbol, True)

            count = max(50, int(count or 300))
            arr = mt5.copy_rates_from_pos(symbol, tf_code, 0, count)
            if arr is None or len(arr) == 0:
                code, msg = mt5.last_error()
                self.acc_status.set(f"Không lấy được rates ({symbol}). last_error={code} {msg}")
                return pd.DataFrame()

            df = pd.DataFrame(arr)
            df["time"] = pd.to_datetime(df["time"], unit="s")
            df.set_index("time", inplace=True)
            df.rename(columns={
                "open": "Open", "high": "High", "low": "Low", "close": "Close",
                "tick_volume": "Volume"
            }, inplace=True)
            if "Volume" not in df.columns:
                df["Volume"] = df.get("real_volume", 0) if "real_volume" in df.columns else 0
            for c in ("Open", "High", "Low", "Close", "Volume"):
                if c in df.columns:
                    df[c] = pd.to_numeric(df[c], errors="coerce")
            df.dropna(subset=["Open", "High", "Low", "Close"], inplace=True)
            return df.tail(count)
        except Exception as e:
            self.acc_status.set(f"Lỗi xử lý rates: {e}")
            return pd.DataFrame()

    def _style(self):
                                          
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            return mpf.make_mpf_style(base_mpf_style="yahoo")
        except Exception:
            return mpf.make_mpf_style(base_mpf_style="classic")

    def _fmt(self, x, digits=5):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - x — (tự suy luận theo ngữ cảnh sử dụng).
          - digits — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            return f"{float(x):.{digits}f}"
        except Exception:
            return str(x)

    def _update_account_info(self, symbol: str):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - symbol: str — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        if not self._ensure_mt5():
            return
        import MetaTrader5 as mt5
        try:
            acc = mt5.account_info()
            if acc:
                self.acc_balance.set(self._fmt(acc.balance, 2))
                self.acc_equity.set(self._fmt(acc.equity, 2))
                self.acc_margin.set(self._fmt(acc.margin_free, 2))
                self.acc_leverage.set(str(getattr(acc, "leverage", "")))
                self.acc_currency.set(getattr(acc, "currency", "") or "-")
                self.acc_status.set(f"OK • {symbol} • {self.tf_var.get()}")
            else:
                self.acc_status.set("Không đọc được account info")
        except Exception:
            self.acc_status.set("Lỗi đọc account info")

    def _fill_positions_table(self, symbol: str):
                                       
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - symbol: str — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        for i in self.tree_pos.get_children():
            self.tree_pos.delete(i)
        if not self._ensure_mt5():
            return
        import MetaTrader5 as mt5
        try:
            info = mt5.symbol_info(symbol)
            digits = getattr(info, "digits", 5) if info else 5
            rows = []

                                
            poss = mt5.positions_get(symbol=symbol) or []
            for p in poss:
                typ = "BUY" if int(getattr(p, "type", 0)) == 0 else "SELL"
                lots = float(getattr(p, "volume", 0.0))
                price = float(getattr(p, "price_open", 0.0))
                sl = float(getattr(p, "sl", 0.0)) or 0.0
                tp = float(getattr(p, "tp", 0.0)) or 0.0
                pnl = float(getattr(p, "profit", 0.0))
                rows.append((
                    int(getattr(p, "ticket", 0)),
                    typ, f"{lots:.2f}", self._fmt(price, digits),
                    (self._fmt(sl, digits) if sl else ""),
                    (self._fmt(tp, digits) if tp else ""),
                    f"{pnl:.2f}",
                ))

                            
            ords = mt5.orders_get(symbol=symbol) or []
            type_map = {
                getattr(mt5, "ORDER_TYPE_BUY_LIMIT", 2):        "BUY LIMIT",
                getattr(mt5, "ORDER_TYPE_SELL_LIMIT", 3):       "SELL LIMIT",
                getattr(mt5, "ORDER_TYPE_BUY_STOP", 4):         "BUY STOP",
                getattr(mt5, "ORDER_TYPE_SELL_STOP", 5):        "SELL STOP",
                getattr(mt5, "ORDER_TYPE_BUY_STOP_LIMIT", 6):   "BUY STOP LIMIT",
                getattr(mt5, "ORDER_TYPE_SELL_STOP_LIMIT", 7):  "SELL STOP LIMIT",
            }
            for o in ords:
                otype = int(getattr(o, "type", 0))
                typ = type_map.get(otype, f"TYPE {otype}")
                lots = float(getattr(o, "volume_current", 0.0))
                price = float(getattr(o, "price_open", 0.0)) or float(getattr(o, "price_current", 0.0))
                sl = float(getattr(o, "sl", 0.0)) or 0.0
                tp = float(getattr(o, "tp", 0.0)) or 0.0
                rows.append((
                    int(getattr(o, "ticket", 0)),
                    typ, f"{lots:.2f}", self._fmt(price, digits),
                    (self._fmt(sl, digits) if sl else ""),
                    (self._fmt(tp, digits) if tp else ""),
                    "",                       
                ))

            try:
                rows.sort(key=lambda r: r[0], reverse=True)
            except Exception:
                pass

            for r in rows:
                self.tree_pos.insert("", "end", values=r)
        except Exception:
            pass

    def _fill_history_table(self, symbol: str):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số:
          - symbol: str — (tự suy luận theo ngữ cảnh sử dụng).
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        for i in self.tree_his.get_children():
            self.tree_his.delete(i)
        if not self._ensure_mt5():
            return
        import MetaTrader5 as mt5
        try:
            from datetime import datetime, timedelta
            now = datetime.now()
            deals = mt5.history_deals_get(now - timedelta(days=1), now) or []
            info = mt5.symbol_info(symbol)
            digits = getattr(info, "digits", 5) if info else 5
            rows = []
            for d in deals:
                try:
                    if getattr(d, "symbol", "") != symbol:
                        continue
                    t = datetime.fromtimestamp(int(getattr(d, "time", 0))).strftime("%Y-%m-%d %H:%M:%S")
                    ticket = int(getattr(d, "ticket", 0))
                    typ_val = int(getattr(d, "type", 0))
                    _typ_map = {
                        getattr(mt5, "DEAL_TYPE_BUY", 0): "BUY",
                        getattr(mt5, "DEAL_TYPE_SELL", 1): "SELL",
                    }
                    typ = _typ_map.get(typ_val, str(typ_val))
                    vol = float(getattr(d, "volume", 0.0))
                    price = float(getattr(d, "price", 0.0))
                    profit = float(getattr(d, "profit", 0.0))
                    rows.append((t, ticket, typ, f"{vol:.2f}", self._fmt(price, digits), f"{profit:.2f}"))
                except Exception:
                    continue
            rows = sorted(rows, key=lambda x: x[0], reverse=True)[:100]
            for r in rows:
                self.tree_his.insert("", "end", values=r)
        except Exception:
            pass

                      
    def _draw_chart(self):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        sym = (self.symbol_var.get() or "").strip()
        tf_code = self._mt5_tf(self.tf_var.get())
        self.ax_price.clear()

        if not sym or tf_code is None:
            self.ax_price.set_title("Nhập Symbol và chọn TF")
            self.canvas.draw_idle()
            return

        df = self._rates_to_df(sym, tf_code, self.n_candles_var.get())

        if df.empty or len(df) < 5:
                                                                             
            self.ax_price.set_title(f"{sym} {self.tf_var.get()} — không có dữ liệu")
            self.canvas.draw_idle()
            self._update_account_info(sym)
            self._fill_positions_table(sym)
            self._fill_history_table(sym)
            return

        st = self._style()
        try:
                                      
            mpf.plot(df, type="candle", ax=self.ax_price, style=st, show_nontrading=False)
        except Exception:
            self.ax_price.plot(df.index, df["Close"])
            self.ax_price.set_title(f"{sym} {self.tf_var.get()} (simple)")

                       
        if self._ensure_mt5():
            try:
                import MetaTrader5 as mt5
                info = mt5.symbol_info(sym)
                digits = getattr(info, "digits", 5) if info else 5

                poss = mt5.positions_get(symbol=sym) or []
                for p in poss:
                    typ_i = int(getattr(p, "type", 0))
                    entry = float(getattr(p, "price_open", 0.0))
                    sl = float(getattr(p, "sl", 0.0)) or None
                    tp = float(getattr(p, "tp", 0.0)) or None
                    col = "#22c55e" if typ_i == 0 else "#ef4444"
                    self.ax_price.axhline(entry, color=col, ls="--", lw=1.0, alpha=0.95)
                    if sl:
                        self.ax_price.axhline(sl, color="#ef4444", ls=":", lw=1.0, alpha=0.85)
                    if tp:
                        self.ax_price.axhline(tp, color="#22c55e", ls=":", lw=1.0, alpha=0.85)
                    label = f"{'BUY' if typ_i==0 else 'SELL'} {getattr(p,'volume',0):.2f} @{self._fmt(entry, digits)}"
                    self.ax_price.text(df.index[-1], entry, "  " + label, va="center", color=col, fontsize=8)

                ords = mt5.orders_get(symbol=sym) or []
                def _otype_txt(t):
                    """
                    Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
                    Tham số:
                      - t — (tự suy luận theo ngữ cảnh sử dụng).
                    Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
                    Ghi chú:
                      - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
                    """
                    m = {
                        getattr(mt5, "ORDER_TYPE_BUY_LIMIT", 2):  "BUY LIMIT",
                        getattr(mt5, "ORDER_TYPE_BUY_STOP", 4):   "BUY STOP",
                        getattr(mt5, "ORDER_TYPE_SELL_LIMIT", 3): "SELL LIMIT",
                        getattr(mt5, "ORDER_TYPE_SELL_STOP", 5):  "SELL STOP",
                    }
                    return m.get(int(t), f"TYPE {t}")
                for o in ords:
                    otype = int(getattr(o, "type", 0))
                    lots  = float(getattr(o, "volume_current", 0.0))
                    px    = float(getattr(o, "price_open", 0.0)) or float(getattr(o, "price_current", 0.0))
                    sl    = float(getattr(o, "sl", 0.0)) or None
                    tp    = float(getattr(o, "tp", 0.0)) or None
                    pend_col = "#8b5cf6"
                    self.ax_price.axhline(px, color=pend_col, ls="--", lw=1.1, alpha=0.95)
                    txt = f"PEND {_otype_txt(otype)} {lots:.2f} @{self._fmt(px, digits)}"
                    self.ax_price.text(df.index[-1], px, "  " + txt, va="center", color=pend_col, fontsize=8)
                    if sl:
                        self.ax_price.axhline(sl, color="#ef4444", ls=":", lw=1.0, alpha=0.85)
                        self.ax_price.text(df.index[-1], sl, "  SL", va="center", color="#ef4444", fontsize=7)
                    if tp:
                        self.ax_price.axhline(tp, color="#22c55e", ls=":", lw=1.0, alpha=0.85)
                        self.ax_price.text(df.index[-1], tp, "  TP", va="center", color="#22c55e", fontsize=7)
            except Exception:
                pass

        self.ax_price.set_title(f"{sym}  •  {self.tf_var.get()}  •  {len(df)} bars")
        self.canvas.draw_idle()

        self._update_account_info(sym)
        self._fill_positions_table(sym)
        self._fill_history_table(sym)

    def _redraw_safe(self):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        try:
            self._draw_chart()
        except Exception as e:
            try:
                self.ax_price.clear()
                self.ax_price.set_title(f"Chart error: {e}")
                self.canvas.draw_idle()
            except Exception:
                pass

    def _tick(self):
        """
        Mục đích: Hàm/thủ tục tiện ích nội bộ phục vụ workflow tổng thể của ứng dụng.
        Tham số: (không)
        Trả về: None hoặc giá trị nội bộ tuỳ ngữ cảnh.
        Ghi chú:
          - Nên gọi trên main thread nếu tương tác trực tiếp với Tkinter; nếu từ worker thread thì sử dụng hàng đợi UI để tránh đụng độ.
        """
        if not self._running:
            return
        self._redraw_safe()
        secs = max(1, int(self.refresh_secs_var.get() or 5))
        self._after_job = self.root.after(secs * 1000, self._tick)

