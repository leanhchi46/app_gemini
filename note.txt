J.[B6Y|5.00<<yB
Chào bạn, tôi đã phân tích kỹ lưỡng mã nguồn của file `scripts/tool.py`. Dưới đây là sơ đồ logic thuật toán và giải thích chi tiết từng phần.

### I. Sơ đồ Logic Thuật toán (Luồng hoạt động chính)

Sơ đồ này mô tả luồng sự kiện chính khi người dùng nhấn nút "Bắt đầu phân tích".

```mermaid
graph TD
    subgraph "Giai đoạn 1: Khởi tạo & Cấu hình"
        A[Người dùng khởi chạy ứng dụng] --> B{Tải Workspace?};
        B -- Có file workspace.json --> C[Nạp cấu hình đã lưu];
        B -- Không --> D[Sử dụng cài đặt mặc định];
        C --> E;
        D --> E[Hiển thị giao diện chính (UI)];
        E --> F[Người dùng chọn thư mục ảnh & cấu hình các tham số];
    end

    subgraph "Giai đoạn 2: Bắt đầu Phân tích (Luồng chính - UI Thread)"
        F -- Bấm nút "Bắt đầu" --> G[start_analysis];
        G --> H{Kiểm tra điều kiện};
        H -- Thiếu thông tin --> I[Hiển thị cảnh báo, dừng lại];
        H -- Đủ thông tin --> J[Tạo bản sao cấu hình (Snapshot Config)];
        J --> K[Reset giao diện & chuẩn bị];
        K --> L[Tạo và khởi chạy Luồng Worker (Worker Thread)];
    end

    subgraph "Giai đoạn 3: Xử lý trong Luồng Worker (Background Thread)"
        L --> M[run_analysis_worker];
        M --> N[Lặp qua từng file ảnh];
        N --> O[Xây dựng Ngữ cảnh (Context)];
        O --> P["- Lấy dữ liệu MT5 (nếu bật)<br>- Lấy báo cáo cũ<br>- Lấy tin tức kinh tế"];
        P --> Q[Gọi API Google Gemini với ảnh và prompt];
        Q --> R[Nhận kết quả phân tích (text)];
        R --> S[Phân tích text để tìm tín hiệu giao dịch (report_parser)];
        S --> T{Có tín hiệu giao dịch?};
        T -- Có --> U[Kiểm tra điều kiện No-Trade/No-Run];
        U -- Vượt qua --> V[Thực hiện Auto-Trade (gửi lệnh tới MT5)];
        U -- Không vượt qua --> W[Bỏ qua, ghi log lý do];
        T -- Không --> W;
        V --> X;
        W --> X;
        X[Gửi thông báo Telegram (nếu có tín hiệu xác suất cao)];
        X --> Y[Cập nhật kết quả vào hàng đợi UI (UI Queue)];
        Y --> N;
        N -- Hết ảnh --> Z[Kết thúc luồng Worker];
    end

    subgraph "Giai đoạn 4: Cập nhật Giao diện & Hoàn tất"
        AA[Luồng UI liên tục kiểm tra UI Queue] --> BB[Lấy cập nhật từ Queue];
        BB --> CC["- Cập nhật thanh tiến trình<br>- Cập nhật trạng thái file trong bảng<br>- Hiển thị báo cáo chi tiết"];
        Z --> DD[Gửi tín hiệu hoàn tất vào UI Queue];
        DD --> EE[Luồng UI nhận tín hiệu, cập nhật trạng thái "Hoàn tất"];
        EE --> FF{Chế độ Auto-Run đang bật?};
        FF -- Có --> GG[Lên lịch cho lần chạy tiếp theo];
        FF -- Không --> HH[Chờ hành động tiếp theo của người dùng];
    end

    Y -.-> AA;
    DD -.-> AA;
```

### II. Giải thích chi tiết các thành phần Code

Ứng dụng được xây dựng quanh lớp `TradingToolApp`, sử dụng thư viện `tkinter` để tạo giao diện người dùng 
và `threading` để xử lý các tác vụ nặng (như gọi API) mà không làm treo giao diện.

#### 1. Khởi tạo và Cấu trúc (`__init__`, `main`)

*   **`main()`**: Là điểm bắt đầu của chương trình. Nó thiết lập logging để ghi lỗi ra file `app_debug.log`, 
tạo cửa sổ chính (`tk.Tk()`) và khởi tạo lớp `TradingToolApp`.
*   **`TradingToolApp.__init__(self, root)`**:
    *   **Thiết lập cửa sổ**: Đặt tiêu đề, kích thước cho cửa sổ ứng dụng.
    *   **Khởi tạo Locks**: Tạo các đối tượng `threading.Lock` (`_trade_log_lock`, `_ui_log_lock`...). 
    Đây là cơ chế cực kỳ quan trọng để đảm bảo rằng khi nhiều luồng cùng cố gắng truy cập một tài nguyên 
    (ví dụ: ghi vào cùng một file log), chúng sẽ phải đợi nhau, tránh xung đột dữ liệu.
    *   **`_init_tk_variables()`**: Khởi tạo tất cả các biến của `tkinter` (như `tk.StringVar`, `tk.BooleanVar`). 
    Các biến này được liên kết với các widget trên giao diện (ô nhập liệu, checkbox...). 
    Khi giá trị của biến thay đổi, widget tương ứng sẽ tự động cập nhật và ngược lại.
    *   **`ui_builder.build_ui(self)`**: Gọi một module bên ngoài (`ui_builder`) để xây dựng toàn bộ các thành phần giao diện 
    (nút bấm, tab, khung nhập liệu...). Việc tách riêng logic giao diện giúp mã nguồn chính (`tool.py`) gọn gàng hơn.
    *   **`_load_workspace()`**: Tải lại các cài đặt từ lần chạy trước được lưu trong file `workspace.json`.
    *   **`_poll_ui_queue(self)`**: Bắt đầu một vòng lặp chạy nền để liên tục kiểm tra `self.ui_queue`. 
    Đây là "cầu nối" để luồng worker có thể gửi yêu cầu cập nhật giao diện một cách an toàn.

#### 2. Luồng Phân tích Chính (`start_analysis`, `worker.run_analysis_worker`)

Đây là trái tim của ứng dụng.

*   **`start_analysis(self)`**:
    1.  **Kiểm tra điều kiện**: Đảm bảo người dùng đã chọn thư mục, nhập API key và prompt.
    2.  **`_snapshot_config()`**: Tạo một "ảnh chụp nhanh" của toàn bộ cấu hình hiện tại trên giao diện và lưu vào một đối tượng `RunConfig`. 
    Điều này rất quan trọng: luồng worker sẽ chạy với bản cấu hình này, dù cho người dùng có thay đổi các tùy chọn trên giao diện trong lúc quá trình phân tích đang diễn ra. Nó đảm bảo tính nhất quán.
    3.  **Cấu hình Gemini**: `genai.configure(api_key=...)`.
    4.  **Reset trạng thái**: Xóa các kết quả cũ, đặt lại thanh tiến trình.
    5.  **Khởi chạy luồng Worker**: Tạo một `threading.Thread` mới, trỏ tới hàm `worker.run_analysis_worker` 
    và truyền vào các tham số cần thiết (bao gồm cả đối tượng `self` để worker có thể gọi lại các hàm của `TradingToolApp`).
     Việc chạy trong luồng riêng giúp giao diện không bị "đơ" trong suốt quá trình xử lý.

*   **`worker.run_analysis_worker(...)`** (Logic nằm trong `src/core/worker.py`):
    1.  **Lặp qua các file ảnh**: Duyệt qua danh sách các file ảnh đã được nạp.
    2.  **Xây dựng Ngữ cảnh (`compose_context`)**: Đây là bước tổng hợp tất cả thông tin cần thiết để cung cấp cho AI, giúp nó đưa ra phân tích chính xác hơn. Ngữ cảnh có thể bao gồm:
        *   Dữ liệu từ MetaTrader 5 (`_mt5_build_context`): Giá cả, chỉ báo kỹ thuật, thông tin tài khoản...
        *   Các báo cáo phân tích cũ để AI "nhớ" các phân tích trước đó.
        *   Thông tin tin tức kinh tế sắp ra (`_refresh_news_cache`).
    3.  **Gọi API Gemini**: Gửi ảnh, prompt và chuỗi ngữ cảnh đã xây dựng tới Google Gemini.
    4.  **Nhận và xử lý kết quả**:
        *   Nhận về một chuỗi văn bản là báo cáo phân tích.
        *   Sử dụng `report_parser` để "dịch" chuỗi văn bản này thành một cấu trúc dữ liệu có tổ chức (gọi là `TradeSetup`), chứa các thông tin như: hướng giao dịch (Buy/Sell), điểm vào lệnh (Entry), cắt lỗ (Stop Loss), chốt lời (Take Profit).
    5.  **Thông báo & Giao dịch**:
        *   `_maybe_notify_telegram()`: Nếu báo cáo chứa cụm từ "HIGH PROBABILITY", nó sẽ gửi thông báo qua Telegram.
        *   `auto_trade.execute_trade()`: Nếu chế độ auto-trade được bật, nó sẽ kiểm tra các điều kiện an toàn (`no_trade.check`) trước khi thực sự gửi lệnh giao dịch tới MT5.
    6.  **Cập nhật giao diện**: Sử dụng `ui_utils._enqueue(self, action)` để đưa một hàm cập nhật giao diện (ví dụ: `_update_tree_row`) vào hàng đợi `ui_queue`. Luồng UI sẽ lấy và thực thi hàm này.

#### 3. Tích hợp Dịch vụ Ngoài

*   **MetaTrader 5 (`_mt5_*` methods)**:
    *   `_mt5_connect()`: Khởi tạo kết nối đến terminal MT5.
    *   `_mt5_build_context()`: Gọi `mt5_utils.build_context` để lấy dữ liệu thị trường (giá nến, thông tin tài khoản, các lệnh đang mở...) và đóng gói chúng lại.
*   **Telegram (`_maybe_notify_telegram`)**:
    *   Tạo "chữ ký" cho báo cáo (`create_report_signature`) để tránh gửi lặp lại cùng một thông báo.
    *   Gọi `telegram_client.send_telegram_message` trong một luồng riêng để việc gửi tin nhắn không làm chậm luồng worker chính.
*   **Google Gemini**: Tương tác chính diễn ra trong luồng worker, thông qua thư viện `google.generativeai`.

#### 4. Quản lý Cấu hình và Workspace (`_save_workspace`, `_load_workspace`)

*   Các phương thức này cho phép lưu và tải toàn bộ trạng thái của các widget trên giao diện vào một file `workspace.json`.
*   Sử dụng `obfuscate_text` và `deobfuscate_text` để mã hóa nhẹ các thông tin nhạy cảm (như API key, Telegram token) trước khi lưu, tăng một lớp bảo mật cơ bản.

#### 5. Chế độ Tự động chạy (`_toggle_autorun`, `_autorun_tick`)

*   Sử dụng `root.after(milliseconds, callback)` của `tkinter` để lên lịch một hàm được thực thi sau một khoảng thời gian nhất định.
*   `_toggle_autorun()`: Bật/tắt chế độ tự động. Khi bật, nó sẽ gọi `_schedule_next_autorun`.
*   `_schedule_next_autorun()`: Hủy lịch chạy cũ (nếu có) và tạo một lịch chạy mới.
*   `_autorun_tick()`: Hàm được thực thi khi đến giờ. Nó sẽ kiểm tra nếu không có phân tích nào đang chạy thì gọi `start_analysis()`,
 bắt đầu một chu trình mới.

Hy vọng phần giải thích và sơ đồ này giúp bạn hiểu rõ hơn về cách hoạt động của ứng dụng. Nếu có bất kỳ phần nào cần làm rõ thêm, đừng ngần ngại hỏi nhé.

Chào bạn, dựa trên phân tích file `scripts/tool.py`, tôi có một số đề xuất để sắp xếp lại mã nguồn một cách hợp lý hơn, 
giúp tăng cường khả năng bảo trì, dễ đọc và mở rộng.
 Hiện tại, file này đang chứa khá nhiều logic khác nhau (UI, quản lý trạng thái, tích hợp dịch vụ bên ngoài) trong một lớp `TradingToolApp` duy nhất.

Dưới đây là kế hoạch đề xuất:

### Kế hoạch sắp xếp lại mã nguồn `scripts/tool.py`

1.  **Tách biệt logic giao diện người dùng (UI) và logic nghiệp vụ (Business Logic)**:
    *   **Hiện trạng**: Lớp `TradingToolApp` đang xử lý cả việc xây dựng UI và các hoạt động cốt lõi của ứng dụng 
    (phân tích, giao dịch, kết nối MT5, Telegram).
    *   **Đề xuất**:
        *   Giữ lại `TradingToolApp` chủ yếu để quản lý các thành phần UI chính, các biến trạng thái của Tkinter, và điều phối các sự kiện UI.
        *   Tạo một lớp mới, ví dụ `TradingCore` hoặc `AppService`, để chứa toàn bộ logic nghiệp vụ:
            *   Quản lý luồng phân tích (`start_analysis`, `stop_analysis`).
            *   Tích hợp với Gemini API.
            *   Xử lý logic giao dịch tự động (`_quick_be_trailing_sweep`, gọi `auto_trade`).
            *   Quản lý kết nối MT5 (`_mt5_connect`, `_mt5_build_context`).
            *   Gửi thông báo Telegram (`_maybe_notify_telegram`).
            *   Quản lý cache tin tức (`_refresh_news_cache`).
            *   Các hàm liên quan đến đọc/ghi file báo cáo, workspace.
        *   `TradingToolApp` sẽ gọi các phương thức của `TradingCore` khi có sự kiện UI xảy ra.

2.  **Nhóm các chức năng liên quan vào các module/lớp nhỏ hơn**:
    *   **Quản lý cấu hình**: Hiện tại `_init_tk_variables` và `_snapshot_config` nằm trong `TradingToolApp`.
        *   **Đề xuất**: Có thể tạo một lớp `AppConfigManager` riêng biệt để xử lý việc khởi tạo, lưu, tải các biến cấu hình từ `workspace.json` và các biến môi trường. Lớp này sẽ cung cấp các phương thức để `TradingToolApp` tương tác.
    *   **Quản lý file và lịch sử**: Các hàm như `_get_reports_dir`, `_load_files`, `_refresh_history_list`, `_preview_history_selected`, `_open_path`, `_delete_history_selected`, `_refresh_json_list`...
        *   **Đề xuất**: Gom các hàm này vào một module hoặc lớp `FileManager` hoặc `ReportManager` riêng.
    *   **Xử lý Prompt**: Các hàm `_extract_text_from_obj`, `_normalize_prompt_text`, `_reformat_prompt_area`, `_load_prompts_from_disk`, `_save_current_prompt_to_disk`.
        *   **Đề xuất**: Gom các hàm này vào một module hoặc lớp `PromptManager`.

3.  **Cải thiện luồng Auto-Run**:
    *   **Hiện trạng**: Logic `_autorun_tick` chứa cả việc bắt đầu phân tích và quản lý BE/Trailing.
    *   **Đề xuất**: Khi tách `TradingCore`, `_autorun_tick` trong `TradingToolApp` sẽ chỉ cần gọi một phương thức tương ứng trong `TradingCore` để kích hoạt chu trình tự động.

### Lợi ích của việc sắp xếp lại:

*   **Dễ đọc và hiểu**: Mỗi lớp/module sẽ có một trách nhiệm rõ ràng, giúp dễ dàng tìm kiếm và hiểu logic hơn.
*   **Dễ bảo trì**: Thay đổi một phần của hệ thống (ví dụ: cách lưu cấu hình) sẽ ít ảnh hưởng đến các phần khác (ví dụ: logic UI).
*   **Dễ kiểm thử**: Các đơn vị logic nhỏ hơn sẽ dễ dàng viết unit test hơn.
*   **Dễ mở rộng**: Khi muốn thêm tính năng mới (ví dụ: tích hợp thêm sàn giao dịch, thêm loại phân tích), việc thêm vào các module/lớp chuyên biệt sẽ dễ dàng hơn.

Bạn có muốn tôi phác thảo cấu trúc file/module mới hoặc đi sâu vào chi tiết hơn về cách tách một phần cụ thể không?
thực hiện các đề xuất sau:
1. Giữ lại `TradingToolApp` chủ yếu để quản lý các thành phần UI chính, các biến trạng thái của Tkinter, và điều phối các sự kiện UI.
2. Tạo một lớp mới `AppService`, để chứa toàn bộ logic nghiệp vụ:
            *   Quản lý luồng phân tích (`start_analysis`, `stop_analysis`).
            *   Tích hợp với Gemini API.
            *   Xử lý logic giao dịch tự động (`_quick_be_trailing_sweep`, gọi `auto_trade`).
            *   Quản lý kết nối MT5 (`_mt5_connect`, `_mt5_build_context`).
            *   Gửi thông báo Telegram (`_maybe_notify_telegram`).
            *   Quản lý cache tin tức (`_refresh_news_cache`).
            *   Các hàm liên quan đến đọc/ghi file báo cáo, workspace.
        *   `TradingToolApp` sẽ gọi các phương thức của `AppService` khi có sự kiện UI xảy ra.
3. tạo một lớp `AppConfigManager` riêng biệt để xử lý việc khởi tạo, lưu, tải các biến cấu hình từ `workspace.json` và các biến môi trường. Lớp này sẽ cung cấp các phương thức để `TradingToolApp` tương tác.
4. Gom các hàm Quản lý file và lịch sử vào một module hoặc lớp  `ReportManager` riêng.
5. Gom các hàm Xử lý Prompt vào một module hoặc lớp `PromptManager`.
6. Cải thiện luồng Auto-Run: Khi tách `TradingCore`, `_autorun_tick` trong `TradingToolApp` sẽ chỉ cần gọi một phương thức tương ứng trong `TradingCore` để kích hoạt chu trình tự động.

Chào bạn, tôi sẽ giải thích chi tiết code và logic của file `src/core/worker_modules/main_worker.py`, cùng với các file liên quan.

### Giải thích file `src/core/worker_modules/main_worker.py`

File `main_worker.py` chứa hàm `run_analysis_worker`, là luồng phân tích chính của ứng dụng. Hàm này điều phối toàn bộ quy trình từ việc chuẩn bị và upload ảnh, xây dựng ngữ cảnh, gọi mô hình AI để phân tích, đến việc xử lý kết quả và thực hiện các hành động giao dịch tự động. Nó được thiết kế để chạy trong một luồng riêng biệt để không làm treo giao diện người dùng.

Dưới đây là các giai đoạn chính trong hàm `run_analysis_worker`:

1.  **GIAI ĐOẠN 1: KHỞI TẠO VÀ KIỂM TRA ĐẦU VÀO**
    *   **Mục đích:** Chuẩn bị danh sách các đường dẫn ảnh cần phân tích và khởi tạo mô hình AI.
    *   **Logic:**
        *   Lấy danh sách các đường dẫn ảnh (`paths`) và tên ảnh (`names`) từ `app.results`.
        *   Áp dụng giới hạn số lượng file tối đa (`cfg.max_files`) nếu được cấu hình.
        *   Kiểm tra nếu không có ảnh nào để phân tích, sẽ dừng quá trình.
        *   Khởi tạo mô hình Gemini (`genai.GenerativeModel`) với `model_name` được truyền vào. Nếu có lỗi khởi tạo mô hình (ví dụ: tên mô hình không hợp lệ như lỗi `404 models/gemini-1.5-flash` trước đó), sẽ hiển thị thông báo lỗi và dừng.

2.  **GIAI ĐOẠN 2: KIỂM TRA ĐIỀU KIỆN NO-RUN**
    *   **Mục đích:** Thực hiện kiểm tra các điều kiện không nên chạy phân tích (ví dụ: cuối tuần, ngoài giờ giao dịch).
    *   **Logic:**
        *   Gọi `trade_conditions.handle_no_run_check(app, cfg)`. Nếu điều kiện `No-Run` được kích hoạt, `early_exit` sẽ được đặt thành `True` và luồng sẽ thoát một cách có kiểm soát.

3.  **GIAI ĐOẠN 3: CHUẨN BỊ VÀ UPLOAD ẢNH**
    *   **Mục đích:** Chuẩn bị các file ảnh để upload lên Gemini và thực hiện upload.
    *   **Logic:**
        *   Tải bộ đệm upload (`UploadCache`) nếu `cfg.cache_enabled` là `True`.
        *   Duyệt qua từng ảnh:
            *   Kiểm tra xem ảnh đã được upload lên Gemini và còn hoạt động trong bộ đệm chưa. Nếu có, sử dụng file đã upload.
            *   Nếu không, chuẩn bị ảnh (tối ưu hóa nếu `cfg.optimize_lossless` là `True`) và thêm vào danh sách `to_upload`.
        *   Nếu `cfg.only_generate_if_changed` là `True` và không có ảnh nào thay đổi (tức là tất cả đều đã có trong cache và đang hoạt động), sẽ kích hoạt `No-Change` và thoát sớm.
        *   Hiển thị trạng thái "Đang upload..." trên UI cho các file cần upload.
        *   Thực hiện upload ảnh song song bằng `image_processor.upload_images_parallel`.
        *   Cập nhật bộ đệm upload sau khi upload thành công.
        *   Kiểm tra `app.stop_flag` để dừng nếu người dùng yêu cầu.

4.  **GIAI ĐOẠN 4: XÂY DỰNG NGỮ CẢNH VÀ KIỂM TRA NO-TRADE**
    *   **Mục đích:** Chuẩn bị dữ liệu từ MetaTrader 5 (MT5) và các ngữ cảnh khác, sau đó kiểm tra các điều kiện không nên giao dịch.
    *   **Logic:**
        *   Gọi `context_coordinator.prepare_and_build_context(app, cfg)` để lấy dữ liệu MT5 an toàn (`safe_mt5_data`), từ điển MT5 (`mt5_dict`), khối ngữ cảnh (`context_block`) và JSON MT5 đầy đủ (`mt5_json_full`).
        *   Hiển thị trạng thái "Context+MT5 xong".
        *   Gọi `trade_conditions.handle_no_trade_check(app, cfg, ...)` để kiểm tra các điều kiện `No-Trade` (ví dụ: tin tức, rủi ro). Nếu điều kiện được kích hoạt, `early_exit` sẽ được đặt thành `True` và luồng sẽ thoát.

5.  **GIAI ĐOẠN 5: GỌI MODEL AI VÀ XỬ LÝ KẾT QUẢ**
    *   **Mục đích:** Gửi các ảnh và prompt đã chuẩn bị đến mô hình AI Gemini, sau đó xử lý phản hồi streaming.
    *   **Logic:**
        *   Tạo danh sách `all_media` chứa các đối tượng media (file đã upload hoặc ảnh inline) từ `file_slots` và `prepared_map`.
        *   Chọn prompt phù hợp (`prompt_no_entry` hoặc `prompt_entry_run`) một cách linh hoạt bằng `prompt_manager.select_prompt_dynamically`.
        *   Xây dựng prompt cuối cùng (`prompt_final`) bằng `prompt_manager.construct_final_prompt`, kết hợp prompt đã chọn với dữ liệu MT5, ngữ cảnh và đường dẫn ảnh.
        *   Tạo danh sách `parts` bao gồm tất cả media và `prompt_final`.
        *   Gọi `api_handlers.stream_and_process_ai_response(app, cfg, model, parts, mt5_dict)` để gửi yêu cầu đến mô hình AI và xử lý phản hồi streaming. Hàm này cũng kích hoạt `auto-trade` ngay trong quá trình nhận dữ liệu từ AI.
        *   Cập nhật thanh tiến trình.

6.  **GIAI ĐOẠN 6: HOÀN TẤT, LƯU TRỮ VÀ DỌN DẸP**
    *   **Mục đích:** Xử lý các tác vụ sau khi phân tích hoàn tất (hoặc bị dừng), bao gồm cập nhật UI, lưu báo cáo, gửi thông báo và dọn dẹp.
    *   **Logic:**
        *   Nếu không có `early_exit`:
            *   Cập nhật trạng thái "Hoàn tất" cho tất cả các file trên UI.
            *   Lưu báo cáo tổng hợp dưới dạng Markdown (`md_saver.save_md_report`) và JSON (`json_saver.save_json_report`).
            *   Làm mới danh sách lịch sử trên UI.
            *   Gửi thông báo Telegram nếu `cfg.telegram_enabled` là `True` và báo cáo chứa tín hiệu giao dịch.
            *   (Phần `trade_actions.mt5_manage_be_trailing` hiện đang bị vô hiệu hóa).
        *   Nếu `cfg.delete_after` là `True` và `cfg.cache_enabled` là `False`, sẽ xóa các file đã upload lên Gemini.
        *   Cập nhật thanh tiến trình về 0% và thông báo cho luồng chính biết worker đã hoàn thành hoặc bị dừng.

### Các file liên quan và vai trò của chúng

Dưới đây là các file khác có liên quan trực tiếp hoặc gián tiếp đến hoạt động của `main_worker.py`:

*   **`src/core/worker_modules/api_handlers.py`**:
    *   **Vai trò:** Xử lý tương tác với API Gemini, bao gồm cơ chế thử lại (retry) và xử lý phản hồi streaming.
    *   **Liên quan:** Hàm `stream_and_process_ai_response` trong file này được gọi bởi `main_worker.py` để gửi yêu cầu đến mô hình AI và nhận kết quả.

*   **`src/core/worker_modules/context_coordinator.py`**:
    *   **Vai trò:** Điều phối việc xây dựng ngữ cảnh cho worker, bao gồm việc lấy dữ liệu từ MetaTrader 5 (MT5) và các báo cáo lịch sử.
    *   **Liên quan:** Hàm `prepare_and_build_context` được gọi để thu thập tất cả dữ liệu cần thiết trước khi gửi đến AI.

*   **`src/core/worker_modules/image_processor.py`**:
    *   **Vai trò:** Xử lý, chuẩn bị và upload ảnh lên Gemini. Bao gồm các chức năng tối ưu hóa ảnh và quản lý bộ đệm upload.
    *   **Liên quan:** Các hàm như `prepare_image`, `upload_images_parallel`, `UploadCache` được sử dụng để quản lý quá trình upload ảnh.

*   **`src/core/worker_modules/prompt_manager.py`**:
    *   **Vai trò:** Quản lý, chọn và xây dựng nội dung prompt (lời nhắc) cho mô hình AI.
    *   **Liên quan:** Các hàm `select_prompt_dynamically` và `construct_final_prompt` được sử dụng để tạo prompt phù hợp dựa trên trạng thái giao dịch và dữ liệu hiện có.

*   **`src/core/worker_modules/trade_conditions.py`**:
    *   **Vai trò:** Điều phối kiểm tra các điều kiện `NO-RUN` (không nên chạy) và `NO-TRADE` (không nên giao dịch), cũng như xử lý thoát sớm.
    *   **Liên quan:** Các hàm `handle_no_run_check` và `handle_no_trade_check` là các "chốt chặn" quan trọng để ngăn chặn việc phân tích hoặc giao dịch trong các điều kiện không thuận lợi.

*   **`src/utils/ui_utils.py`**:
    *   **Vai trò:** Chứa các hàm tiện ích để cập nhật giao diện người dùng (UI) một cách an toàn từ các luồng phụ.
    *   **Liên quan:** Được sử dụng rộng rãi trong `main_worker.py` để cập nhật trạng thái, tiến trình và hiển thị thông báo trên UI.

*   **`src/utils/json_saver.py` và `src/utils/md_saver.py`**:
    *   **Vai trò:** Các tiện ích để lưu báo cáo dưới dạng JSON và Markdown.
    *   **Liên quan:** Được sử dụng ở giai đoạn cuối để lưu trữ kết quả phân tích.

*   **`src/config/constants.py`**:
    *   **Vai trò:** Chứa các hằng số của ứng dụng, bao gồm tên mô hình AI mặc định (`DEFAULT_MODEL`).
    *   **Liên quan:** Định nghĩa `DEFAULT_MODEL` mà `main_worker.py` sử dụng để khởi tạo mô hình AI.

*   **`src/config/config.py`**:
    *   **Vai trò:** Định nghĩa lớp `RunConfig` chứa tất cả các cài đặt cấu hình cho một lần chạy phân tích.
    *   **Liên quan:** Đối tượng `cfg` được truyền vào `run_analysis_worker` là một instance của `RunConfig`, chứa tất cả các tham số điều khiển hành vi của worker.

*   **`scripts/tool.py`**:
    *   **Vai trò:** Script chính để khởi chạy ứng dụng, thiết lập môi trường và khởi tạo giao diện người dùng.
    *   **Liên quan:** Đây là điểm vào của ứng dụng, nơi `TradingToolApp` được tạo và `main_worker.py` được gọi thông qua `app_logic.start_analysis`.

*   **`src/ui/app_ui.py`**:
    *   **Vai trò:** Định nghĩa lớp giao diện người dùng chính (`TradingToolApp`), quản lý các widget và tương tác người dùng.
    *   **Liên quan:** `main_worker.py` tương tác với đối tượng `app` (một instance của `TradingToolApp`) để cập nhật UI và truy cập các thuộc tính của ứng dụng.

*   **`src/core/app_logic.py`**:
    *   **Vai trò:** Chứa logic nghiệp vụ chính của ứng dụng, điều phối các thành phần khác và cung cấp các phương thức được gọi từ UI.
    *   **Liên quan:** `TradingToolApp` ủy quyền nhiều tác vụ cho `AppLogic`, và `AppLogic` lại gọi `run_analysis_worker` trong một luồng riêng.

Hy vọng phần giải thích này giúp bạn hiểu rõ hơn về cách `main_worker.py` hoạt động và mối quan hệ của nó với các thành phần khác trong dự án.

Tôi đã phân tích các file trong thư mục `src/core/worker_modules` và hiểu rõ luồng logic cũng như sự liên kết giữa chúng. Dưới đây là tóm tắt và sơ đồ trực quan:

**Tóm tắt phân tích:**

1.  **`main_worker.py`**: Là trung tâm điều phối chính, 
quản lý toàn bộ quy trình phân tích và giao dịch tự động theo từng giai đoạn: 
khởi tạo, kiểm tra điều kiện NO-RUN, chuẩn bị/upload ảnh, 
xây dựng ngữ cảnh/kiểm tra NO-TRADE, gọi AI và xử lý kết quả, 
cuối cùng là lưu trữ báo cáo và dọn dẹp.

2.  **`api_handlers.py`**: Chuyên xử lý tương tác với API Gemini,
 bao gồm cơ chế retry cho streaming và khả năng kích hoạt auto-trade
  ngay trong quá trình nhận dữ liệu từ AI.

3.  **`context_coordinator.py`**: Tập hợp các thông tin cần thiết 
(lịch sử, dữ liệu MT5 thời gian thực, phân tích tin tức) 
để tạo ngữ cảnh đầy đủ cho model AI.

4.  **`image_processor.py`**: Đảm nhiệm việc tối ưu hóa và 
upload các file ảnh biểu đồ lên Gemini, có cơ chế cache để tăng hiệu quả.

5.  **`prompt_manager.py`**: Quản lý việc lựa chọn prompt phù hợp 
dựa trên trạng thái giao dịch và xây dựng nội dung prompt cuối cùng
 bằng cách tích hợp các dữ liệu liên quan.

6.  **`trade_actions.py`**: Chứa logic cốt lõi cho việc thực hiện giao dịch tự động. 
Nó phân tích kết quả từ AI, kiểm tra các điều kiện giao dịch
 (như tỷ lệ R:R, khoảng cách đến key level), 
 tính toán khối lượng và gửi lệnh đến MetaTrader 5. 
 Nó cũng ghi lại các quyết định giao dịch.
7.  **`trade_conditions.py`**: Đóng vai trò là các "chốt chặn" sớm, 
kiểm tra các điều kiện tổng thể (NO-RUN) và các điều kiện giao dịch cụ thể (NO-TRADE)
 để quyết định có nên tiếp tục hay thoát sớm.

**Sơ đồ luồng logic trực quan:**

```mermaid
graph TD
    A[scripts/tool.py (TradingToolApp)] --> B(main_worker.py::run_analysis_worker)

    B -- Giai đoạn 1: Khởi tạo --> C{Kiểm tra đầu vào & Khởi tạo Model}
    C --> D{Kiểm tra NO-RUN}
    D -- True (Thoát sớm) --> E[Kết thúc Worker]
    D -- False (Tiếp tục) --> F{Chuẩn bị & Upload ảnh}

    F -- Sử dụng --> G[image_processor.py]
    G -- Tối ưu hóa ảnh --> G1(prepare_image)
    G -- Upload song song --> G2(upload_images_parallel)
    G -- Quản lý cache --> G3(UploadCache)

    F --> H{Xây dựng ngữ cảnh & Kiểm tra NO-TRADE}

    H -- Sử dụng --> I[context_coordinator.py]
    I -- Xây dựng ngữ cảnh lịch sử --> I1(context_builder.compose_context)
    I -- Lấy dữ liệu MT5 --> I2(app._mt5_build_context)
    I -- Phân tích tin tức --> I3(services/news.py)

    H -- Sử dụng --> J[trade_conditions.py]
    J -- Kiểm tra NO-RUN --> J1(handle_no_run_check)
    J -- Kiểm tra NO-TRADE --> J2(handle_no_trade_check)
    J -- Xử lý không thay đổi --> J3(handle_no_change_scenario)

    H --> K{Gọi Model AI & Xử lý kết quả}

    K -- Sử dụng --> L[prompt_manager.py]
    L -- Chọn prompt động --> L1(select_prompt_dynamically)
    L -- Xây dựng prompt cuối cùng --> L2(construct_final_prompt)
    L -- Phân tích báo cáo --> L3(utils/report_parser.py)

    K -- Sử dụng --> M[api_handlers.py]
    M -- Gọi API streaming với retry --> M1(_gen_stream_with_retry)
    M -- Xử lý stream & Auto-Trade --> M2(stream_and_process_ai_response)

    M2 -- Kích hoạt trong stream --> N[trade_actions.py::auto_trade_if_high_prob]
    N -- Kiểm tra NO-TRADE --> N1(no_trade.evaluate)
    N -- Phân tích setup từ AI --> N2(report_parser.extract_json_block_prefer)
    N -- Gửi lệnh MT5 --> N3(_order_send_smart)
    N -- Ghi log giao dịch --> N4(_log_trade_decision)

    K --> O{Hoàn tất, Lưu trữ & Dọn dẹp}
    O -- Lưu báo cáo MD --> O1(utils/md_saver.save_md_report)
    O -- Lưu báo cáo JSON --> O2(utils/json_saver.save_json_report)
    O -- Gửi Telegram (tùy chọn) --> O3(services/telegram_client.py)
    O -- Dọn dẹp file upload --> O4(image_processor.maybe_delete_uploaded_file)

    O --> E
```

Sơ đồ này minh họa cách `main_worker.py` điều phối các module khác để thực hiện quy trình phân tích và giao dịch tự động, từ việc chuẩn bị dữ liệu đến tương tác với AI và thực hiện các hành động giao dịch.

Bạn có muốn tôi đi sâu vào chi tiết hơn về bất kỳ module hoặc luồng logic cụ thể nào không? Hoặc bạn đã hài lòng với phân tích này và muốn tôi chuyển sang chế độ ACT để thực hiện một tác vụ khác?